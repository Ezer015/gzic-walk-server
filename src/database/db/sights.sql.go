// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: sights.sql

package db

import (
	"context"
)

const getSight = `-- name: GetSight :one
SELECT
    sight_id,
    sight_name,
    sight_description
FROM
    sights
WHERE
    sight_id = $1
`

type GetSightRow struct {
	SightID          int32  `json:"sight_id"`
	SightName        string `json:"sight_name"`
	SightDescription string `json:"sight_description"`
}

func (q *Queries) GetSight(ctx context.Context, sightID int32) (GetSightRow, error) {
	row := q.db.QueryRow(ctx, getSight, sightID)
	var i GetSightRow
	err := row.Scan(&i.SightID, &i.SightName, &i.SightDescription)
	return i, err
}

const getSightName = `-- name: GetSightName :one
SELECT
    sight_name
FROM
    sights
WHERE
    sight_id = $1
`

func (q *Queries) GetSightName(ctx context.Context, sightID int32) (string, error) {
	row := q.db.QueryRow(ctx, getSightName, sightID)
	var sight_name string
	err := row.Scan(&sight_name)
	return sight_name, err
}

const getSights = `-- name: GetSights :many
SELECT
    sight_id,
    sight_name,
    sight_description
FROM
    sights
`

type GetSightsRow struct {
	SightID          int32  `json:"sight_id"`
	SightName        string `json:"sight_name"`
	SightDescription string `json:"sight_description"`
}

func (q *Queries) GetSights(ctx context.Context) ([]GetSightsRow, error) {
	rows, err := q.db.Query(ctx, getSights)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSightsRow
	for rows.Next() {
		var i GetSightsRow
		if err := rows.Scan(&i.SightID, &i.SightName, &i.SightDescription); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
